# Day 1: Bootstrap the Monolith

**Date**: February 11, 2026  
**Status**: âœ… Complete

## ğŸ¯ Goals

- Create NestJS application with strict TypeScript
- Add ConfigModule with environment validation
- Implement `/health` endpoint
- Set up modular folder structure
- Configure linting and formatting
- Document setup and run instructions

## âœ… Definition of Done

- [x] App starts locally with one command
- [x] `/health` endpoint returns 200
- [x] Repo has lint/format scripts and a readable README
- [x] Day-01 notes committed

## ğŸ—ï¸ What Was Built

### 1. Project Initialization
```bash
npm install -g @nestjs/cli
nest new monolith-api --skip-git --package-manager npm --strict
```

- Created NestJS project with strict TypeScript mode
- Configured with npm package manager
- Enabled strict type checking in `tsconfig.json`

### 2. Dependencies Installed
```bash
npm install @nestjs/config @nestjs/terminus class-validator class-transformer
```

**Core Dependencies:**
- `@nestjs/config` - Configuration management with validation
- `@nestjs/terminus` - Health check endpoints
- `class-validator` - DTO validation decorators
- `class-transformer` - Object transformation utilities

### 3. Configuration System

Created a robust configuration system with validation:

**Files Created:**
- `src/config/app.config.ts` - Application configuration factory
- `src/config/env.validation.ts` - Environment variable validation schema
- `.env` - Environment variables (git-ignored)
- `.env.example` - Example environment template

**Features:**
- Type-safe configuration access
- Runtime validation of environment variables
- Centralized configuration namespace
- Fails fast on invalid configuration

### 4. Health Check Endpoint

**File:** `src/health/health.controller.ts`

```typescript
@Controller('health')
export class HealthController {
  @Get()
  @HealthCheck()
  check() {
    return this.health.check([]);
  }
}
```

**Endpoint:** `GET /health`  
**Response:**
```json
{
  "status": "ok",
  "info": {},
  "error": {},
  "details": {}
}
```

### 5. Modular Folder Structure

Created feature module directories:
```
src/modules/
â”œâ”€â”€ auth/          # Authentication & JWT
â”œâ”€â”€ orgs/          # Organization management
â”œâ”€â”€ users/         # User management
â”œâ”€â”€ events/        # Event CRUD
â””â”€â”€ moderation/    # Event moderation
```

Created common cross-cutting directories:
```
src/common/
â”œâ”€â”€ filters/       # Exception filters
â”œâ”€â”€ guards/        # Auth & role guards
â”œâ”€â”€ interceptors/  # Request/response transformation
â”œâ”€â”€ pipes/         # Custom validation pipes
â””â”€â”€ decorators/    # Custom parameter decorators
```

### 6. Application Bootstrap

**File:** `src/main.ts`

Enhanced with:
- Configuration service integration
- Global validation pipe (whitelist, transform, forbid unknown properties)
- CORS enabled
- Informative startup logging

### 7. Linting & Formatting

**Available Scripts:**
```bash
npm run lint      # ESLint with auto-fix
npm run format    # Prettier formatting
```

**Configuration Files:**
- `eslint.config.mjs` - ESLint rules (generated by NestJS)
- `.prettierrc` - Prettier formatting rules

All code passes linting and formatting checks.

## ğŸ“ Key Learnings

### NestJS vs .NET Parallels

| Concept | NestJS | .NET Core |
|---------|--------|-----------|
| DI Container | `@Module({ providers: [] })` | `services.AddScoped<>()` |
| Configuration | `ConfigModule.forRoot()` | `IConfiguration` + Options pattern |
| Validation | `class-validator` decorators | Data Annotations / FluentValidation |
| Health Checks | `@nestjs/terminus` | ASP.NET HealthChecks |
| Middleware | `app.use()` / `@Injectable()` | `app.UseMiddleware<>()` |

### Best Practices Applied

1. **Strict TypeScript**: Enabled strict mode for type safety
2. **Environment Validation**: Runtime validation prevents deployment with invalid config
3. **Global Pipes**: Centralized validation at application level
4. **Modular Structure**: Clear separation of concerns from day one
5. **Documentation**: README and daily notes for knowledge retention

### Configuration Pattern

The configuration system uses a **layered approach**:
1. `.env` file (git-ignored) for local secrets
2. `env.validation.ts` for schema definition and runtime validation
3. `app.config.ts` for typed configuration namespaces
4. `ConfigService` for type-safe access throughout the app

This is similar to .NET's Options pattern but with runtime validation built-in.

## ğŸ› Issues Encountered & Fixed

### Issue 1: ESLint Floating Promise Warning
**Problem:** `bootstrap()` call triggered a no-floating-promises warning

**Solution:** Wrapped the call with `void` operator:
```typescript
void bootstrap();
```

This explicitly marks the promise as intentionally not awaited (as it's the application entry point).

## ğŸ§ª Testing

### Manual Testing
```bash
# Start the application
npm run start:dev

# Test health endpoint
curl http://localhost:3000/health
```

**Expected Response:**
```json
{
  "status": "ok",
  "info": {},
  "error": {},
  "details": {}
}
```

### Automated Testing
```bash
# Unit tests
npm run test

# Linting
npm run lint

# Format check
npm run format
```

All tests pass âœ…

## ğŸ“Š Metrics

- **Files Created**: 15+
- **Dependencies Added**: 4
- **Lines of Code**: ~150
- **Time Spent**: ~2 hours
- **Commits**: 1 (Day 1 Complete)

## ğŸš€ Running the Application

### Development Mode
```bash
cd e:\Backend\monolith-api
npm run start:dev
```

Application available at: `http://localhost:3000`

### Production Build
```bash
npm run build
npm run start:prod
```

## ğŸ“š References

- [NestJS Documentation](https://docs.nestjs.com)
- [NestJS Configuration](https://docs.nestjs.com/techniques/configuration)
- [NestJS Health Checks](https://docs.nestjs.com/recipes/terminus)
- [Class Validator](https://github.com/typestack/class-validator)

## â­ï¸ Next Steps (Day 2)

**Planned Tasks:**
1. Install Prisma ORM
2. Set up PostgreSQL database
3. Create User and Organization models
4. Implement auth module:
   - Signup endpoint
   - Login endpoint
   - JWT generation
   - Password hashing with bcrypt
5. Add JWT strategy and auth guard
6. Implement `/me` endpoint
7. Write unit tests for auth service

**Deliverables:**
- Working authentication flow
- Database schema for users and organizations
- Protected endpoints using JWT
- Comprehensive tests

## ğŸ’­ Reflection

Day 1 successfully established a solid foundation for the EventBoard API. The modular structure will make it easy to add features incrementally. The configuration system with validation ensures we catch issues early. The health check provides a baseline for monitoring.

The strict TypeScript configuration will help catch type errors during development, similar to C#'s compile-time checking. The global validation pipe means we don't need to remember to validate DTOs manuallyâ€”it happens automatically.

**What went well:**
- Clean project setup with no major issues
- Configuration validation working perfectly
- Clear folder structure from the start

**What to improve:**
- Consider adding Docker Compose from day 1 for database
- Add API versioning strategy early
- Consider adding Swagger/OpenAPI documentation sooner

---

**Commit Message:**
```
feat(day-01): bootstrap monolith with health check and config

- Initialize NestJS project with strict TypeScript
- Add ConfigModule with runtime validation
- Implement /health endpoint using Terminus
- Set up modular folder structure (auth, orgs, users, events, moderation)
- Configure ESLint and Prettier
- Add comprehensive README and documentation
```
